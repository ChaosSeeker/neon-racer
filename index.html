<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Neon Highway Racer (Shop + Coins + Share)</title>
  <style>
    :root { --bg:#050814; --panel:#0b1230; --text:#eaf0ff; --muted:#9fb0e6; }
    *{box-sizing:border-box}
    body{
      margin:0; min-height:100vh; display:grid; place-items:center;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background: radial-gradient(1200px 700px at 50% 15%, #1a2a7a 0%, var(--bg) 60%);
      color:var(--text);
      overflow:hidden;
    }
    .wrap{width:min(1100px, 95vw); display:grid; gap:14px;}
    header{
      background:rgba(11,18,48,.82);
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px; padding:12px 14px;
      display:flex; align-items:center; justify-content:space-between; flex-wrap:wrap; gap:10px;
      box-shadow:0 12px 30px rgba(0,0,0,.35);
      backdrop-filter: blur(10px);
    }
    h1{margin:0; font-size:16px; letter-spacing:.3px}
    .sub{font-size:12px; color:var(--muted)}
    .left{display:flex; flex-direction:column; gap:2px}
    .stats{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .pill{
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      padding:8px 12px; border-radius:999px; font-size:13px;
      display:flex; gap:6px; align-items:center;
    }
    .pill b{font-weight:900}
    .bar{
      width:120px; height:8px; border-radius:999px;
      background:rgba(255,255,255,.10);
      border:1px solid rgba(255,255,255,.10);
      overflow:hidden;
    }
    .bar > i{display:block; height:100%; width:50%; background:rgba(120,255,220,.85)}
    .btns{display:flex; gap:8px; flex-wrap:wrap}
    button{
      cursor:pointer; color:var(--text);
      background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.16);
      border-radius:12px; padding:10px 12px;
      font-weight:900; font-size:13px;
      transition:.15s transform,.15s background;
      user-select:none;
    }
    button:hover{background:rgba(255,255,255,.12)}
    button:active{transform:translateY(1px)}
    .board{
      background:rgba(11,18,48,.62);
      border:1px solid rgba(255,255,255,.10);
      border-radius:18px; padding:12px;
      box-shadow:0 12px 30px rgba(0,0,0,.35);
      backdrop-filter: blur(10px);
    }
    canvas{
      width:100%;
      height:auto;
      aspect-ratio: 16 / 9;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      display:block;
      touch-action:none;
    }
    .help{
      margin-top:10px;
      display:flex; justify-content:space-between; gap:10px; flex-wrap:wrap;
      color:var(--muted); font-size:13px;
    }
    .kbd{font-family: ui-monospace,SFMono-Regular,Menlo,monospace}

    /* Mobile controls */
    .mobileControls{
      display:none;
      margin-top:10px;
      gap:10px;
      flex-wrap:wrap;
      justify-content:space-between;
      align-items:center;
      user-select:none;
    }
    .pad{display:flex; gap:10px; align-items:center}
    .big{
      padding:14px 16px;
      border-radius:16px;
      font-size:14px;
      min-width:92px;
      text-align:center;
    }
    @media (max-width: 760px){
      .mobileControls{display:flex}
    }

    /* Overlay menu */
    .overlay{
      position:fixed; inset:0;
      display:grid; place-items:center;
      background:rgba(0,0,0,.58);
      backdrop-filter: blur(6px);
      padding:18px;
    }
    .modal{
      width:min(760px, 94vw);
      background:rgba(11,18,48,.94);
      border:1px solid rgba(255,255,255,.14);
      border-radius:18px;
      padding:16px;
      box-shadow:0 24px 70px rgba(0,0,0,.6);
    }
    .modal h2{margin:0 0 8px; font-size:18px}
    .modal p{margin:0 0 12px; color:var(--muted); line-height:1.5}
    .row{display:flex; gap:10px; flex-wrap:wrap}
    .choices{display:grid; gap:10px; grid-template-columns: repeat(3, minmax(0, 1fr));}
    .card{
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      border-radius:16px; padding:12px;
      cursor:pointer;
      transition:.15s transform, .15s background, .15s border;
      user-select:none;
    }
    .card:hover{transform:translateY(-2px); background:rgba(255,255,255,.09)}
    .card b{display:block; margin-bottom:4px}
    .tag{font-size:12px; color:var(--muted)}
    .small{font-size:12px; color:var(--muted)}
    .tog{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .chip{
      display:inline-flex; gap:8px; align-items:center;
      padding:8px 10px; border-radius:999px;
      background:rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.12);
      cursor:pointer; user-select:none;
      font-size:13px; font-weight:900;
    }
    .chip input{accent-color:#6ff; cursor:pointer}

    /* Shop */
    .shop{
      margin-top:12px;
      display:grid;
      gap:10px;
      grid-template-columns: repeat(4, minmax(0, 1fr));
    }
    .shopItem{
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      border-radius:16px;
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:8px;
      min-height:120px;
    }
    .shopItem .top{display:flex; justify-content:space-between; gap:8px; align-items:center}
    .shopItem .name{font-weight:900}
    .shopItem .desc{font-size:12px; color:var(--muted); line-height:1.35}
    .shopItem .buyRow{display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-top:auto}
    .price{font-size:12px; color:var(--muted)}
    .qty{
      display:inline-flex;
      min-width:26px;
      justify-content:center;
      padding:2px 8px;
      border-radius:999px;
      background:rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.12);
      font-size:12px;
      font-weight:900;
    }
    @media (max-width:900px){ .shop{grid-template-columns:1fr 1fr} }
    @media (max-width:520px){ .shop{grid-template-columns:1fr} }

    /* Emoji overlay (DOM) */
    .emojiLayer{
      position:fixed; inset:0; pointer-events:none;
    }
    .emojiPop{
      position:absolute;
      transform: translate(-50%, -50%) scale(1);
      font-size:44px;
      filter: drop-shadow(0 10px 18px rgba(0,0,0,.45));
      will-change: transform, opacity;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="left">
        <h1>Neon Highway Racer ‚Äî Deluxe+</h1>
        <div class="sub">Lane-changing traffic ‚Ä¢ Coins ‚Ä¢ Shop buffs ‚Ä¢ Share ‚Ä¢ Emojis ‚Ä¢ Music</div>
      </div>

      <div class="stats">
        <div class="pill">Score: <b id="score">0</b></div>
        <div class="pill">Best: <b id="best">0</b></div>
        <div class="pill">Level: <b id="level">Easy</b></div>
        <div class="pill" title="Nitro">
          Nitro:
          <span class="bar"><i id="nitroFill"></i></span>
        </div>
        <div class="pill" title="Coins in this run">
          Run ü™ô: <b id="runCoins">0</b>
        </div>
        <div class="pill" title="Total coins saved">
          Bank ü™ô: <b id="bankCoins">0</b>
        </div>
        <div class="pill" title="Active power-ups">
          Buffs: <b id="pu">‚Äî</b>
        </div>
      </div>

      <div class="btns">
        <button id="pauseBtn" title="Pause/Resume (Space)">Pause</button>
        <button id="restartBtn" title="Restart (R)">Restart</button>
        <button id="feedbackBtn" title="Feedback on Instagram">Feedback</button>
      </div>
    </header>

    <div class="board">
      <canvas id="game" width="960" height="540"></canvas>

      <div class="help">
        <div>
          Controls: <span class="kbd">‚Üê ‚Üí</span>/<span class="kbd">A D</span> steer ‚Ä¢
          <span class="kbd">‚Üë</span>/<span class="kbd">W</span> nitro ‚Ä¢
          <span class="kbd">Shift</span> drift ‚Ä¢
          <span class="kbd">Space</span> pause ‚Ä¢ <span class="kbd">R</span> restart
        </div>
        <div class="small">Mobile: buttons below (or swipe left/right; swipe up = nitro)</div>
      </div>

      <div class="mobileControls">
        <div class="pad">
          <button class="big" id="mLeft">‚óÄ Left</button>
          <button class="big" id="mRight">Right ‚ñ∂</button>
        </div>
        <div class="pad">
          <button class="big" id="mDrift">‚ö° Drift</button>
          <button class="big" id="mNitro">üöÄ Nitro</button>
        </div>
      </div>
    </div>
  </div>

  <div class="overlay" id="menu">
    <div class="modal">
      <h2 id="menuTitle">Choose start difficulty + Shop</h2>
      <p id="menuText">
        Collect coins during gameplay, then buy buffs here. Difficulty also upgrades automatically as you score.
      </p>

      <div class="row" style="justify-content:space-between; align-items:center">
        <div class="choices" style="flex:1">
          <div class="card" data-mode="easy">
            <b>Easy</b>
            <div class="tag">More space ‚Ä¢ slower ramp</div>
          </div>
          <div class="card" data-mode="medium">
            <b>Medium</b>
            <div class="tag">Balanced ‚Ä¢ faster traffic</div>
          </div>
          <div class="card" data-mode="hard">
            <b>Hard</b>
            <div class="tag">Dense ‚Ä¢ aggressive speed</div>
          </div>
        </div>
      </div>

      <div style="height:10px"></div>

      <div class="tog">
        <span class="chip" style="cursor:default">Bank ü™ô <b id="menuBank" style="margin-left:6px">0</b></span>
        <label class="chip"><input id="musicToggle" type="checkbox" checked /> Music</label>
        <label class="chip"><input id="sfxToggle" type="checkbox" checked /> SFX</label>
      </div>

      <div class="shop" aria-label="Shop">
        <div class="shopItem">
          <div class="top">
            <div class="name">üõ° Shield</div>
            <span class="qty" id="qShield">0</span>
          </div>
          <div class="desc">Blocks 1 crash. Stack up to 2.</div>
          <div class="buyRow">
            <button data-buy="shield">Buy</button>
            <span class="price">Cost: <b>20</b> ü™ô</span>
          </div>
        </div>

        <div class="shopItem">
          <div class="top">
            <div class="name">‚è± Slow-Mo</div>
            <span class="qty" id="qSlowmo">0</span>
          </div>
          <div class="desc">Slows time for a few seconds.</div>
          <div class="buyRow">
            <button data-buy="slowmo">Buy</button>
            <span class="price">Cost: <b>25</b> ü™ô</span>
          </div>
        </div>

        <div class="shopItem">
          <div class="top">
            <div class="name">üß≤ Magnet</div>
            <span class="qty" id="qMagnet">0</span>
          </div>
          <div class="desc">Pulls coins toward you.</div>
          <div class="buyRow">
            <button data-buy="magnet">Buy</button>
            <span class="price">Cost: <b>25</b> ü™ô</span>
          </div>
        </div>

        <div class="shopItem">
          <div class="top">
            <div class="name">üöÄ Nitro+</div>
            <span class="qty" id="qNitro">0</span>
          </div>
          <div class="desc">Start with extra nitro.</div>
          <div class="buyRow">
            <button data-buy="nitro">Buy</button>
            <span class="price">Cost: <b>15</b> ü™ô</span>
          </div>
        </div>
      </div>

      <div style="height:10px"></div>

      <div class="row">
        <button id="playBtn">Play</button>
        <button id="shareBtn" style="display:none">Share</button>
        <button id="closeBtn">Close</button>
      </div>

      <p class="small" style="margin-top:10px">
        Coins help you buy buffs. Close calls trigger a WOW üò≤. Game over shows a crying emoji üò≠.
      </p>
    </div>
  </div>

  <div class="emojiLayer" id="emojiLayer"></div>

<script>
(() => {
  // ========= Canvas =========
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const W = canvas.width, H = canvas.height;

  // ========= UI =========
  const scoreEl = document.getElementById("score");
  const bestEl  = document.getElementById("best");
  const levelEl = document.getElementById("level");
  const nitroFill = document.getElementById("nitroFill");
  const puEl = document.getElementById("pu");
  const runCoinsEl = document.getElementById("runCoins");
  const bankCoinsEl = document.getElementById("bankCoins");

  const pauseBtn = document.getElementById("pauseBtn");
  const restartBtn = document.getElementById("restartBtn");
  const feedbackBtn = document.getElementById("feedbackBtn");

  const menu = document.getElementById("menu");
  const playBtn = document.getElementById("playBtn");
  const closeBtn = document.getElementById("closeBtn");
  const shareBtn = document.getElementById("shareBtn");
  const menuTitle = document.getElementById("menuTitle");
  const menuText  = document.getElementById("menuText");

  const musicToggle = document.getElementById("musicToggle");
  const sfxToggle = document.getElementById("sfxToggle");

  const menuBank = document.getElementById("menuBank");

  const qShield = document.getElementById("qShield");
  const qSlowmo = document.getElementById("qSlowmo");
  const qMagnet = document.getElementById("qMagnet");
  const qNitro  = document.getElementById("qNitro");

  const emojiLayer = document.getElementById("emojiLayer");

  // Mobile buttons
  const mLeft = document.getElementById("mLeft");
  const mRight = document.getElementById("mRight");
  const mNitro = document.getElementById("mNitro");
  const mDrift = document.getElementById("mDrift");

  // ========= Difficulty =========
  const MODES = {
    easy:   { name:"Easy",   baseSpeed: 235, accel: 10, spawnRate: 0.90, maxTraffic: 7,  wiggle: 40, trafficRelMin:0.62, trafficRelMax:1.00, laneChangeRate: 0.06 },
    medium: { name:"Medium", baseSpeed: 295, accel: 14, spawnRate: 1.12, maxTraffic: 10, wiggle: 55, trafficRelMin:0.62, trafficRelMax:1.12, laneChangeRate: 0.10 },
    hard:   { name:"Hard",   baseSpeed: 355, accel: 18, spawnRate: 1.35, maxTraffic: 13, wiggle: 75, trafficRelMin:0.65, trafficRelMax:1.22, laneChangeRate: 0.14 },
  };
  const LEVELS = [
    { key:"easy",   at: 0 },
    { key:"medium", at: 1200 },
    { key:"hard",   at: 2600 }
  ];

  // ========= Storage =========
  const BEST_KEY = "neon_racer_best_deluxe_v2";
  const BANK_KEY = "neon_racer_coin_bank_v1";
  let best = Number(localStorage.getItem(BEST_KEY) || 0);

  let bankCoins = Number(localStorage.getItem(BANK_KEY) || 0);
  function saveBank(){
    localStorage.setItem(BANK_KEY, String(bankCoins));
    bankCoinsEl.textContent = bankCoins;
    menuBank.textContent = bankCoins;
  }

  bestEl.textContent = best;
  saveBank();

  // ========= Road / Lanes =========
  const road = { x: W * 0.18, w: W * 0.64, y: 0, h: H };
  const laneCount = 3;
  const laneW = road.w / laneCount;

  function laneCenter(lane){ return road.x + laneW * (lane + 0.5); }

  // ========= Game State =========
  let baseModeKey = "easy";
  let baseMode = MODES[baseModeKey];
  let levelKey = "easy";
  let levelMode = MODES[levelKey];

  let running = false;
  let paused = false;
  let last = performance.now();

  let score = 0;
  let speed = 0;
  let roadY = 0;

  // Coins
  let runCoins = 0;

  // Shop purchases applied at run start
  const cart = { shield:0, slowmo:0, magnet:0, nitro:0 };
  const PRICES = { shield:20, slowmo:25, magnet:25, nitro:15 };

  // Buff timers/state
  const power = {
    shield: 0,
    slowmoT: 0,
    magnetT: 0,
  };

  // Nitro state
  let nitro = 1.0;      // 0..1
  let nitroActive = false;

  // Drift state
  let driftActive = false;

  const keys = new Set();

  const player = {
    x: laneCenter(1),
    y: H * 0.78,
    w: 46,
    h: 86,
    vx: 0,
    targetX: null,
    alive: true
  };

  const traffic = [];
  const coins = [];
  const sparks = [];
  const stars = Array.from({length: 90}, () => ({
    x: Math.random() * W, y: Math.random() * H, s: 0.5 + Math.random()*1.6
  }));

  // ========= Audio: Music + SFX =========
  let audioCtx = null;
  let master = null;
  let musicGain = null;
  let song = null;

  function ensureAudio(){
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    master = audioCtx.createGain();
    master.gain.value = 0.35;
    master.connect(audioCtx.destination);

    musicGain = audioCtx.createGain();
    musicGain.gain.value = musicToggle.checked ? 0.22 : 0.0;
    musicGain.connect(master);

    // Light ‚Äúsong‚Äù: kick + hat + bass + lead (synth)
    song = createSong(audioCtx, musicGain);
    song.start();
  }

  function createSong(ctx, out){
    const tempo = 112; // bpm
    const beat = 60 / tempo;
    const state = { t: ctx.currentTime, timer: null, on: true };

    const bus = ctx.createGain();
    bus.gain.value = 0.9;
    bus.connect(out);

    const lp = ctx.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.value = 900;
    bus.connect(lp);
    lp.connect(out);

    function kick(t){
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = "sine";
      o.frequency.setValueAtTime(140, t);
      o.frequency.exponentialRampToValueAtTime(52, t + 0.10);
      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(0.65, t + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t + 0.14);
      o.connect(g); g.connect(bus);
      o.start(t); o.stop(t + 0.16);
    }

    function hat(t){
      const dur = 0.03;
      const buffer = ctx.createBuffer(1, ctx.sampleRate * dur, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i=0;i<data.length;i++) data[i] = (Math.random()*2-1) * Math.exp(-i/(data.length/2));
      const src = ctx.createBufferSource();
      src.buffer = buffer;
      const g = ctx.createGain();
      const hp = ctx.createBiquadFilter();
      hp.type = "highpass"; hp.frequency.value = 5000;

      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(0.20, t + 0.005);
      g.gain.exponentialRampToValueAtTime(0.0001, t + dur);

      src.connect(hp); hp.connect(g); g.connect(bus);
      src.start(t); src.stop(t + dur);
    }

    function bass(t, freq){
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      const f = ctx.createBiquadFilter();
      o.type = "triangle";
      o.frequency.setValueAtTime(freq, t);
      f.type = "lowpass";
      f.frequency.value = 280;

      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(0.22, t + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t + beat*0.95);

      o.connect(f); f.connect(g); g.connect(bus);
      o.start(t); o.stop(t + beat);
    }

    function lead(t, freq){
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = "sawtooth";
      o.frequency.setValueAtTime(freq, t);

      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(0.12, t + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t + beat*0.75);

      o.connect(g); g.connect(bus);
      o.start(t); o.stop(t + beat*0.8);
    }

    const scale = [0, 3, 5, 7, 10]; // minor pentatonic
    function noteFreq(semi){
      return 220 * Math.pow(2, semi/12);
    }

    function schedule(){
      if (!state.on) return;
      const now = ctx.currentTime;
      while (state.t < now + 0.12){
        const step = Math.round((state.t - 0) / (beat/2));
        // Kick on beats
        if (step % 4 === 0) kick(state.t);
        // Hats on offbeats
        if (step % 2 === 1) hat(state.t);

        // Bass pattern every beat
        if (step % 2 === 0){
          const barPos = Math.floor(step/2) % 8;
          const root = [0, 0, -2, -2, -5, -5, -2, -2][barPos]; // simple progression
          bass(state.t, noteFreq(root - 12));
        }

        // Lead every beat, random-ish
        if (step % 2 === 0){
          const idx = (Math.floor(step/2) + 2) % scale.length;
          lead(state.t, noteFreq(scale[idx] + 12));
        }

        state.t += beat/2;
      }
      state.timer = setTimeout(schedule, 50);
    }

    return {
      start(){
        state.on = true;
        state.t = ctx.currentTime;
        schedule();
      },
      stop(){
        state.on = false;
        if (state.timer) clearTimeout(state.timer);
      }
    };
  }

  function sfx(type){
    if (!sfxToggle.checked) return;
    ensureAudio();
    const t0 = audioCtx.currentTime;
    const g = audioCtx.createGain();
    g.connect(master);

    if (type === "coin"){
      const o = audioCtx.createOscillator();
      o.type = "square";
      o.frequency.setValueAtTime(880, t0);
      o.frequency.exponentialRampToValueAtTime(1320, t0 + 0.06);
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(0.22, t0 + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.12);
      o.connect(g); o.start(t0); o.stop(t0 + 0.13);
      return;
    }

    if (type === "pickup"){
      const o = audioCtx.createOscillator();
      o.type = "triangle";
      o.frequency.setValueAtTime(520, t0);
      o.frequency.exponentialRampToValueAtTime(820, t0 + 0.08);
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(0.20, t0 + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.16);
      o.connect(g); o.start(t0); o.stop(t0 + 0.17);
      return;
    }

    if (type === "crash"){
      const dur = 0.35;
      const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * dur, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i=0;i<data.length;i++){
        data[i] = (Math.random()*2-1) * Math.exp(-i/(data.length/4));
      }
      const src = audioCtx.createBufferSource();
      src.buffer = buffer;
      const f = audioCtx.createBiquadFilter();
      f.type = "lowpass"; f.frequency.value = 900;

      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(0.45, t0 + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

      src.connect(f); f.connect(g);
      src.start(t0); src.stop(t0 + dur);
      return;
    }
  }

  musicToggle.addEventListener("change", () => {
    ensureAudio();
    musicGain.gain.value = musicToggle.checked ? 0.22 : 0.0;
  });

  // Start audio on first interaction
  window.addEventListener("pointerdown", () => { ensureAudio(); audioCtx.resume?.(); }, { once:false });

  // ========= Helpers =========
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
  function randInt(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
  function lerp(a,b,t){ return a + (b-a)*t; }
  function rectHit(ax,ay,aw,ah, bx,by,bw,bh){
    const aL = ax-aw/2, aR = ax+aw/2, aT = ay-ah/2, aB = ay+ah/2;
    const bL = bx-bw/2, bR = bx+bw/2, bT = by-bh/2, bB = by+bh/2;
    return (aL < bR && aR > bL && aT < bB && aB > bT);
  }
  function distRect(ax,ay,aw,ah, bx,by,bw,bh){
    const aL = ax-aw/2, aR = ax+aw/2, aT = ay-ah/2, aB = ay+ah/2;
    const bL = bx-bw/2, bR = bx+bw/2, bT = by-bh/2, bB = by+bh/2;
    const dx = Math.max(bL - aR, aL - bR, 0);
    const dy = Math.max(bT - aB, aT - bB, 0);
    return Math.hypot(dx, dy);
  }

  // ========= Emoji effects =========
  function popEmoji(emoji, x, y, duration=650){
    const el = document.createElement("div");
    el.className = "emojiPop";
    el.textContent = emoji;
    el.style.left = x + "px";
    el.style.top = y + "px";
    el.style.opacity = "0";
    emojiLayer.appendChild(el);

    const start = performance.now();
    function anim(now){
      const t = (now - start) / duration;
      if (t >= 1){
        el.remove();
        return;
      }
      const ease = t<0.5 ? 2*t*t : 1 - Math.pow(-2*t+2,2)/2;
      const scale = 0.7 + 0.9*ease;
      const floatY = -22 * ease;
      el.style.opacity = String(1 - t*0.9);
      el.style.transform = `translate(-50%, -50%) translateY(${floatY}px) scale(${scale})`;
      requestAnimationFrame(anim);
    }
    requestAnimationFrame(anim);
  }

  let cryingEl = null;
  function showCrying(){
    if (cryingEl) return;
    cryingEl = document.createElement("div");
    cryingEl.className = "emojiPop";
    cryingEl.textContent = "üò≠";
    cryingEl.style.left = "50%";
    cryingEl.style.top = "35%";
    cryingEl.style.fontSize = "86px";
    cryingEl.style.opacity = "0.95";
    emojiLayer.appendChild(cryingEl);

    let t0 = performance.now();
    function pulse(now){
      if (!cryingEl) return;
      const t = (now - t0) / 1000;
      const s = 1 + Math.sin(t*4) * 0.07;
      cryingEl.style.transform = `translate(-50%, -50%) scale(${s})`;
      requestAnimationFrame(pulse);
    }
    requestAnimationFrame(pulse);
  }
  function hideCrying(){
    cryingEl?.remove();
    cryingEl = null;
  }

  // ========= Input =========
  window.addEventListener("keydown", (e) => {
    const k = e.key.toLowerCase();
    keys.add(k);
    if (k === " "){ e.preventDefault(); togglePause(); }
    if (k === "r") { e.preventDefault(); reset(); }
  });
  window.addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()));

  function togglePause(){
    if (!running) return;
    paused = !paused;
    last = performance.now();
    syncUI();
  }

  pauseBtn.addEventListener("click", togglePause);
  restartBtn.addEventListener("click", reset);

  feedbackBtn.addEventListener("click", () => {
    window.open("https://www.instagram.com/daily__discipline.01/", "_blank", "noopener,noreferrer");
  });

  function holdButton(btn, downFn, upFn){
    const down = (e)=>{ e.preventDefault(); downFn(); };
    const up = (e)=>{ e.preventDefault(); upFn(); };
    btn.addEventListener("pointerdown", down);
    btn.addEventListener("pointerup", up);
    btn.addEventListener("pointercancel", up);
    btn.addEventListener("pointerleave", up);
  }

  holdButton(mLeft,  ()=> keys.add("arrowleft"), ()=> keys.delete("arrowleft"));
  holdButton(mRight, ()=> keys.add("arrowright"),()=> keys.delete("arrowright"));
  holdButton(mNitro, ()=> keys.add("arrowup"),   ()=> keys.delete("arrowup"));
  holdButton(mDrift, ()=> keys.add("shift"),     ()=> keys.delete("shift"));

  // Touch swipe
  let touchStart = null;
  canvas.addEventListener("pointerdown", (e) => touchStart = {x:e.clientX, y:e.clientY});
  canvas.addEventListener("pointerup", (e) => {
    if (!touchStart) return;
    const dx = e.clientX - touchStart.x;
    const dy = e.clientY - touchStart.y;
    touchStart = null;
    const ax = Math.abs(dx), ay = Math.abs(dy);
    if (Math.max(ax, ay) < 18) return;
    if (ax > ay){
      if (dx > 0) steer(1); else steer(-1);
    } else if (dy < 0){
      keys.add("arrowup");
      setTimeout(()=>keys.delete("arrowup"), 140);
    }
  });

  function steer(dir){
    const lane = clamp(Math.floor((player.x - road.x) / laneW), 0, laneCount-1);
    const nextLane = clamp(lane + dir, 0, laneCount-1);
    player.targetX = laneCenter(nextLane);
  }

  // ========= Traffic / Coins Spawning =========
  let spawnTimer = 0;
  let coinTimer = 0;

  function spawnCar(){
    if (traffic.length >= levelMode.maxTraffic) return;
    const lane = randInt(0, laneCount-1);
    const x = laneCenter(lane);
    const ok = !traffic.some(t => t.lane === lane && t.y < 150);
    if (!ok) return;

    traffic.push({
      lane,
      targetLane: lane,
      x,
      y: -120,
      w: 44,
      h: 84,
      rel: lerp(levelMode.trafficRelMin, levelMode.trafficRelMax, Math.random()),
      seed: Math.random(),
      laneChangeCooldown: 0.4 + Math.random()*1.0
    });
  }

  function spawnCoin(){
    if (coins.length >= 10) return;
    const lane = randInt(0, laneCount-1);
    coins.push({
      lane,
      x: laneCenter(lane),
      y: -60,
      r: 12,
      spin: Math.random()*10
    });
  }

  // ========= Level compute =========
  function setBaseMode(key){
    baseModeKey = key;
    baseMode = MODES[baseModeKey];
  }

  function computeLevel(){
    // score thresholds + start difficulty shift
    let shift = 0;
    if (baseModeKey === "medium") shift = 250;
    if (baseModeKey === "hard") shift = 550;

    const s = score + shift;
    let k = "easy";
    for (const lv of LEVELS){
      if (s >= lv.at) k = lv.key;
    }
    levelKey = k;
    levelMode = MODES[levelKey];
  }

  // ========= Shop =========
  function syncShopUI(){
    qShield.textContent = cart.shield;
    qSlowmo.textContent = cart.slowmo;
    qMagnet.textContent = cart.magnet;
    qNitro.textContent  = cart.nitro;
    menuBank.textContent = bankCoins;
  }

  function buy(item){
    const cost = PRICES[item];
    if (bankCoins < cost) return;
    // caps
    if (item === "shield" && cart.shield >= 2) return;
    if (item === "slowmo" && cart.slowmo >= 3) return;
    if (item === "magnet" && cart.magnet >= 3) return;
    if (item === "nitro"  && cart.nitro  >= 3) return;

    bankCoins -= cost;
    cart[item] += 1;
    saveBank();
    syncShopUI();
    sfx("pickup");
  }

  document.querySelectorAll("button[data-buy]").forEach(btn => {
    btn.addEventListener("click", () => buy(btn.getAttribute("data-buy")));
  });

  // ========= Reset / Start Run =========
  function applyCartToRun(){
    power.shield = cart.shield;
    power.slowmoT = cart.slowmo * 4.5;
    power.magnetT = cart.magnet * 6.0;

    // Nitro+ gives extra starting nitro
    nitro = clamp(1.0 + cart.nitro * 0.25, 0, 1.75);
    // reset cart after applying
    cart.shield = cart.slowmo = cart.magnet = cart.nitro = 0;
    syncShopUI();
  }

  function reset(){
    hideCrying();

    score = 0;
    runCoins = 0;
    speed = baseMode.baseSpeed;
    roadY = 0;

    nitroActive = false;
    driftActive = false;

    power.shield = 0;
    power.slowmoT = 0;
    power.magnetT = 0;

    player.x = laneCenter(1);
    player.vx = 0;
    player.targetX = null;
    player.alive = true;

    traffic.length = 0;
    coins.length = 0;
    sparks.length = 0;

    applyCartToRun();

    running = true;
    paused = false;
    last = performance.now();

    computeLevel();
    syncUI();
  }

  function syncUI(){
    scoreEl.textContent = Math.floor(score);
    bestEl.textContent = best;
    levelEl.textContent = MODES[levelKey].name;

    // nitro bar: map 0..1.75 -> 0..100
    nitroFill.style.width = Math.round(clamp(nitro/1.0, 0, 1) * 100) + "%";

    runCoinsEl.textContent = runCoins;
    bankCoinsEl.textContent = bankCoins;

    const list = [];
    if (power.shield > 0) list.push("Shield√ó" + power.shield);
    if (power.slowmoT > 0) list.push("Slow-Mo");
    if (power.magnetT > 0) list.push("Magnet");
    puEl.textContent = list.length ? list.join(", ") : "‚Äî";

    pauseBtn.textContent = paused ? "Resume" : "Pause";
  }

  // ========= Particles =========
  function makeSparks(x,y,count,drift){
    for (let i=0;i<count;i++){
      const fast = drift ? 0.75 : 1.0;
      sparks.push({
        x: x + (Math.random()*18-9),
        y: y + (Math.random()*18-9),
        vx: (Math.random()*2-1) * 520 * fast,
        vy: -(120 + Math.random()*520) * fast,
        life: 0.16 + Math.random()*0.22,
        c: Math.random() < 0.5 ? "rgba(255,210,60,1)" : "rgba(255,90,220,1)"
      });
    }
  }

  // ========= Update =========
  function update(dtRaw){
    computeLevel();

    const timeScale = power.slowmoT > 0 ? 0.70 : 1.0;
    let dt = dtRaw * timeScale;

    // Speed
    speed += levelMode.accel * dt;

    // Nitro
    const nitroKey = keys.has("arrowup") || keys.has("w");
    nitroActive = nitroKey && nitro > 0.02 && !paused && running;
    if (nitroActive){
      nitro = Math.max(0, nitro - dt * 0.35);
    } else {
      nitro = Math.min(1.75, nitro + dt * 0.18);
    }

    // Drift
    driftActive = keys.has("shift");
    const steerLeft  = keys.has("arrowleft") || keys.has("a");
    const steerRight = keys.has("arrowright") || keys.has("d");

    const nitroBoost = nitroActive ? 170 : 0;
    const effectiveSpeed = speed + nitroBoost;

    // Road scroll
    roadY += effectiveSpeed * dt;
    if (roadY > 60) roadY -= 60;

    // Steering
    const steerPower = driftActive ? 3400 : 2400;
    if (steerLeft)  player.vx -= steerPower * dt;
    if (steerRight) player.vx += steerPower * dt;

    if (player.targetX !== null){
      const dx = player.targetX - player.x;
      player.vx += dx * 18 * dt;
      if (Math.abs(dx) < 3) { player.x = player.targetX; player.targetX = null; player.vx *= 0.2; }
    }

    const friction = driftActive ? 0.00135 : 0.0008;
    player.vx *= Math.pow(friction, dt);
    player.x += player.vx * dt;

    // Clamp road
    const minX = road.x + player.w*0.55;
    const maxX = road.x + road.w - player.w*0.55;
    player.x = clamp(player.x, minX, maxX);

    // Drift sparks
    if (driftActive && (steerLeft || steerRight) && Math.abs(player.vx) > 160){
      if (Math.random() < 0.35) makeSparks(player.x, player.y + player.h*0.40, 10, true);
    }

    // Spawn traffic
    spawnTimer += dt * levelMode.spawnRate * (0.85 + effectiveSpeed/560);
    if (spawnTimer >= 1){
      spawnTimer = 0;
      spawnCar();
      if (levelKey !== "easy" && Math.random() < 0.28) spawnCar();
      if (levelKey === "hard" && Math.random() < 0.35) spawnCar();
    }

    // Spawn coins
    coinTimer += dt * (0.65 + effectiveSpeed/900);
    if (coinTimer >= 1){
      coinTimer = 0;
      if (Math.random() < 0.85) spawnCoin();
      if (levelKey !== "easy" && Math.random() < 0.25) spawnCoin();
    }

    // Move traffic + lane changing
    for (let i = traffic.length - 1; i >= 0; i--){
      const t = traffic[i];

      t.y += effectiveSpeed * dt * t.rel;

      // Slight weave
      t.x += Math.sin((t.y/120) + t.seed*10) * dt * levelMode.wiggle * 0.35;

      // Lane change decision
      t.laneChangeCooldown -= dt;
      if (t.laneChangeCooldown <= 0 && Math.random() < levelMode.laneChangeRate){
        const dir = Math.random() < 0.5 ? -1 : 1;
        const nextLane = clamp(t.targetLane + dir, 0, laneCount-1);

        // avoid switching into another car near same Y
        const safe = !traffic.some(o =>
          o !== t &&
          o.targetLane === nextLane &&
          Math.abs(o.y - t.y) < 110
        );

        if (safe) t.targetLane = nextLane;
        t.laneChangeCooldown = 0.8 + Math.random()*1.4;
      }

      // Smoothly move to lane center
      const targetX = laneCenter(t.targetLane);
      t.x += (targetX - t.x) * dt * 6.0;

      // update lane approximation for spawning checks
      t.lane = clamp(Math.round((t.x - road.x)/laneW), 0, laneCount-1);

      if (t.y > H + 140) traffic.splice(i, 1);
    }

    // Move coins
    for (let i = coins.length - 1; i >= 0; i--){
      const c = coins[i];
      c.y += effectiveSpeed * dt * 0.90;
      c.spin += dt * 8;

      // Magnet: pull coins toward player
      if (power.magnetT > 0){
        const dx = player.x - c.x;
        c.x += dx * dt * 2.8;
      } else {
        // keep roughly in its lane
        c.x += (laneCenter(c.lane) - c.x) * dt * 2.0;
      }

      if (c.y > H + 60) coins.splice(i, 1);
    }

    // Score gain
    score += dt * (effectiveSpeed * 0.055);
    if (nitroActive) score += dt * 22;
    if (driftActive && (steerLeft || steerRight)) score += dt * 10;

    // Close call WOW emoji
    for (const t of traffic){
      const d = distRect(player.x, player.y, player.w, player.h, t.x, t.y, t.w, t.h);
      if (d < 10 && d > 0){
        score += dt * 48;
        if (Math.random() < 0.08){
          const rect = canvas.getBoundingClientRect();
          popEmoji("üò≤", rect.left + rect.width*(player.x/W), rect.top + rect.height*(player.y/H));
        }
        if (Math.random() < 0.30) makeSparks(player.x, player.y - player.h*0.25, 6, false);
      }
    }

    // Collect coins
    for (let i = coins.length - 1; i >= 0; i--){
      const c = coins[i];
      // treat coin as small rect for hit check
      if (rectHit(player.x, player.y, player.w*0.9, player.h*0.9, c.x, c.y, c.r*2, c.r*2)){
        coins.splice(i, 1);
        runCoins += 1;
        score += 15;
        sfx("coin");
      }
    }

    // Collision with traffic
    for (const t of traffic){
      if (rectHit(player.x, player.y, player.w, player.h, t.x, t.y, t.w, t.h)){
        handleCrash();
        break;
      }
    }

    // Timers
    power.slowmoT = Math.max(0, power.slowmoT - dtRaw);
    power.magnetT = Math.max(0, power.magnetT - dtRaw);

    // Sparks
    for (let i = sparks.length - 1; i >= 0; i--){
      const s = sparks[i];
      s.vy += 900 * dt;
      s.x += s.vx * dt;
      s.y += s.vy * dt;
      s.life -= dt;
      if (s.life <= 0) sparks.splice(i, 1);
    }

    // Best
    const sc = Math.floor(score);
    if (sc > best){
      best = sc;
      localStorage.setItem(BEST_KEY, String(best));
    }

    syncUI();
  }

  function handleCrash(){
    if (power.shield > 0){
      power.shield -= 1;
      makeSparks(player.x, player.y, 28, false);
      player.vx *= -0.35;
      score = Math.max(0, score - 120);
      return;
    }
    crash();
  }

  function crash(){
    player.alive = false;
    running = false;
    makeSparks(player.x, player.y, 44, false);
    sfx("crash");

    // bank the coins from this run
    bankCoins += runCoins;
    runCoins = 0;
    saveBank();

    showMenu(true);
  }

  // ========= Draw =========
  function roundRect(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function drawCar(x, y, w, h, isPlayer, seed){
    ctx.save();
    const shake = (levelKey==="hard" && speed > 520 && running) ? (Math.random()*2-1) * 1.2 : 0;
    ctx.translate(shake, 0);

    const bodyGrad = ctx.createLinearGradient(x-w/2, y-h/2, x+w/2, y+h/2);
    if (isPlayer){
      bodyGrad.addColorStop(0, "rgba(90,255,200,.95)");
      bodyGrad.addColorStop(1, "rgba(80,170,255,.92)");
    } else {
      const a = 0.85;
      bodyGrad.addColorStop(0, `rgba(${Math.floor(200+seed*40)},${Math.floor(60+seed*120)},255,${a})`);
      bodyGrad.addColorStop(1, `rgba(255,${Math.floor(60+seed*140)},${Math.floor(160+seed*80)},${a})`);
    }

    ctx.shadowBlur = isPlayer ? 18 : 14;
    ctx.shadowColor = isPlayer ? "rgba(80,255,220,.9)" : "rgba(255,80,220,.55)";
    ctx.fillStyle = bodyGrad;
    roundRect(x - w/2, y - h/2, w, h, 14);
    ctx.fill();

    ctx.shadowBlur = 0;
    ctx.fillStyle = "rgba(0,0,0,.28)";
    roundRect(x - w*0.32, y - h*0.22, w*0.64, h*0.28, 10);
    ctx.fill();

    ctx.fillStyle = isPlayer ? "rgba(255,255,255,.85)" : "rgba(255,210,40,.8)";
    ctx.fillRect(x - w*0.36, y - h*0.45, w*0.16, 6);
    ctx.fillRect(x + w*0.20, y - h*0.45, w*0.16, 6);

    ctx.fillStyle = isPlayer ? "rgba(255,70,120,.8)" : "rgba(90,255,200,.55)";
    ctx.fillRect(x - w*0.36, y + h*0.40, w*0.16, 6);
    ctx.fillRect(x + w*0.20, y + h*0.40, w*0.16, 6);

    if (isPlayer && nitroActive && running){
      ctx.globalAlpha = 0.95;
      ctx.fillStyle = "rgba(255,255,255,.10)";
      roundRect(x - w*0.20, y + h*0.55, w*0.40, 52, 14);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    ctx.restore();
  }

  function drawCoin(c){
    ctx.save();
    const pulse = 1 + Math.sin(c.spin) * 0.12;
    ctx.shadowBlur = 18;
    ctx.shadowColor = "rgba(255,210,60,0.95)";
    ctx.fillStyle = "rgba(255,210,60,0.92)";
    ctx.beginPath();
    ctx.arc(c.x, c.y, c.r * pulse, 0, Math.PI*2);
    ctx.fill();

    ctx.shadowBlur = 0;
    ctx.fillStyle = "rgba(0,0,0,.25)";
    ctx.beginPath();
    ctx.arc(c.x, c.y, c.r * 0.55, 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = "rgba(255,255,255,.92)";
    ctx.font = "900 13px system-ui, sans-serif";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("ü™ô", c.x, c.y + 0.5);
    ctx.restore();
  }

  function draw(){
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle = "#050814";
    ctx.fillRect(0,0,W,H);

    // stars
    ctx.globalAlpha = 0.6;
    for (const st of stars){
      ctx.fillRect(st.x, st.y, st.s, st.s);
      st.y += (speed * 0.02) * (st.s) * 0.03;
      if (st.y > H) { st.y = -5; st.x = Math.random()*W; }
    }
    ctx.globalAlpha = 1;

    // road
    const grad = ctx.createLinearGradient(road.x, 0, road.x + road.w, 0);
    grad.addColorStop(0, "rgba(20,240,255,.10)");
    grad.addColorStop(0.5, "rgba(255,255,255,.05)");
    grad.addColorStop(1, "rgba(255,70,220,.10)");
    ctx.fillStyle = grad;
    roundRect(road.x, 0, road.w, H, 22);
    ctx.fill();

    // edges
    ctx.strokeStyle = "rgba(255,255,255,.16)";
    ctx.lineWidth = 2;
    roundRect(road.x, 0, road.w, H, 22);
    ctx.stroke();

    // lane lines dashed
    ctx.save();
    ctx.beginPath();
    ctx.rect(road.x, 0, road.w, H);
    ctx.clip();
    ctx.strokeStyle = "rgba(255,255,255,.20)";
    ctx.lineWidth = 2;
    for (let i=1;i<laneCount;i++){
      const lx = road.x + laneW * i;
      for (let y=-80; y < H+80; y += 60){
        const yy = y + (roadY % 60);
        ctx.beginPath();
        ctx.moveTo(lx, yy);
        ctx.lineTo(lx, yy + 26);
        ctx.stroke();
      }
    }
    ctx.restore();

    // coins
    for (const c of coins) drawCoin(c);

    // traffic
    for (const t of traffic){
      drawCar(t.x, t.y, t.w, t.h, false, t.seed);
    }

    // player
    drawCar(player.x, player.y, player.w, player.h, true, 0.3);

    // shield ring
    if (power.shield > 0){
      ctx.save();
      ctx.globalAlpha = 0.7;
      ctx.strokeStyle = "rgba(120,255,220,.85)";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(player.x, player.y, 58, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }

    // slowmo tint
    if (power.slowmoT > 0){
      ctx.save();
      ctx.globalAlpha = 0.12;
      ctx.fillStyle = "rgba(140,170,255,1)";
      ctx.fillRect(0,0,W,H);
      ctx.restore();
    }

    // sparks
    for (const s of sparks){
      ctx.globalAlpha = Math.max(0, Math.min(1, s.life / 0.35));
      ctx.fillStyle = s.c;
      ctx.fillRect(s.x, s.y, 3, 3);
    }
    ctx.globalAlpha = 1;

    // pause overlay
    if (paused && running){
      ctx.fillStyle = "rgba(0,0,0,.45)";
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = "rgba(255,255,255,.92)";
      ctx.font = "bold 44px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("PAUSED", W/2, H/2);
    }
  }

  // ========= Menu / Share =========
  let pendingMode = "easy";

  function showMenu(isGameOver=false){
    menu.style.display = "grid";
    shareBtn.style.display = isGameOver ? "inline-block" : "none";
    menuTitle.textContent = isGameOver ? "Game Over!" : "Choose start difficulty + Shop";
    menuText.textContent = isGameOver
      ? `Final score: ${Math.floor(score)}. Coins added to bank. Buy buffs and play again.`
      : "Collect coins during gameplay, then buy buffs here. Difficulty also upgrades automatically as you score.";
    syncShopUI();
    syncUI();
    if (isGameOver) showCrying();
  }
  function hideMenu(){
    menu.style.display = "none";
    hideCrying();
  }

  document.querySelectorAll(".card[data-mode]").forEach(card => {
    card.addEventListener("click", () => {
      pendingMode = card.getAttribute("data-mode");
      document.querySelectorAll(".card").forEach(c => c.style.borderColor = "rgba(255,255,255,.14)");
      card.style.borderColor = "rgba(120,255,220,.85)";
    });
  });

  playBtn.addEventListener("click", () => {
    setBaseMode(pendingMode);
    hideMenu();
    reset();
  });

  closeBtn.addEventListener("click", () => {
    hideMenu();
    if (!running) { setBaseMode(pendingMode); reset(); }
  });

  shareBtn.addEventListener("click", async () => {
    const finalScore = Math.floor(score);
    const text = `I scored ${finalScore} in Neon Highway Racer! Can you beat me? üèéÔ∏èüî•\nPlay: ${location.href}`;
    try{
      if (navigator.share){
        await navigator.share({ title: "Neon Highway Racer", text, url: location.href });
      } else if (navigator.clipboard){
        await navigator.clipboard.writeText(text);
        alert("Copied to clipboard! Paste it on WhatsApp/Instagram.");
      } else {
        prompt("Copy this message:", text);
      }
    } catch {
      // user cancelled / blocked ‚Äî do nothing
    }
  });

  // ========= Main Loop =========
  function loop(now){
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    if (running && !paused){
      update(dt);
    }
    draw();
    requestAnimationFrame(loop);
  }

  // ========= Start =========
  bestEl.textContent = best;
  document.querySelector(`.card[data-mode="${pendingMode}"]`)?.click();
  showMenu(false);
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
